<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: contribs/gmf/src/directives/layertree.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: contribs/gmf/src/directives/layertree.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>goog.provide('gmf.LayertreeController');
goog.provide('gmf.layertreeDirective');

goog.require('gmf');
goog.require('ngeo.CreatePopup');
goog.require('ngeo.LayerHelper');
goog.require('ngeo.LayertreeController');
goog.require('ol.Collection');
goog.require('ol.layer.Tile');


gmf.module.value('gmfLayertreeTemplate',
    /**
     * @param {angular.JQLite} element Element.
     * @param {angular.Attributes} attrs Attributes.
     * @return {string} Template.
     */
    function(element, attrs) {
      var subTemplateUrl = gmf.baseTemplateUrl + '/layertree.html';
      return '&lt;div ngeo-layertree="gmfLayertreeCtrl.tree" ' +
          'ngeo-layertree-map="gmfLayertreeCtrl.map" ' +
          'ngeo-layertree-nodelayer="gmfLayertreeCtrl.getLayer(node, depth)" ' +
          'ngeo-layertree-listeners="gmfLayertreeCtrl.listeners(treeScope, ' +
          'treeCtrl)" ' +
          'ngeo-layertree-templateurl="' + subTemplateUrl + '"' +
          '&lt;/div>';
    });


// Overrides the path to the layertree template (used by each nodes, except
// the root node that path is defined by the gmfLayertreeTemplate value.
ngeo.module.value('ngeoLayertreeTemplateUrl',
    /**
     * @param {angular.JQLite} element Element.
     * @param {angular.Attributes} attrs Attributes.
     * @return {string} Template URL.
     */
    function(element, attrs) {
      return gmf.baseTemplateUrl + '/layertree.html';
    });


/**
 * This directive creates a layertree based on the c2cgeoportal JSON themes
 * source and a {@link ngeo.layertreeDirective}. The controller used by this
 * directive defines some fonctions for each node that are created by a default
 * template. This default template can be overrided by setting the constant
 * 'gmf.layertreeTemplateUrl' but you will must adapt the
 * ngeoLayertreeTemplateUrl value too (to define the children's nodes template
 * path).
 *
 * Example:
 *
 *      &lt;gmf-layertree
 *        gmf-layertree-source="ctrl.source"
 *        gmf-layertree-map="ctrl.map"
 *      &lt;/gmf-layertree>
 *
 * You can add an attribute 'gmf-layertree-openlinksinnewwindow="true"' to open
 * metadata URLs in a new window. By default, and in the default template,
 * links will be opened in a popup.
 *
 * @param {string|function(!angular.JQLite=, !angular.Attributes=)}
 *     gmfLayertreeTemplate Template for the directive.
 * @return {angular.Directive} The directive specs.
 * @ngInject
 * @ngdoc directive
 * @ngname gmfLayertreeDirective
 */
gmf.layertreeDirective = function(gmfLayertreeTemplate) {
  return {
    scope: {
      'map': '=gmfLayertreeMap',
      'tree': '=gmfLayertreeSource',
      'openLinksInNewWindowFn': '&amp;gmfLayertreeOpenlinksinnewwindow'
    },
    bindToController: true,
    controller: 'GmfLayertreeController',
    controllerAs: 'gmfLayertreeCtrl',
    template: gmfLayertreeTemplate
  };
};

gmf.module.directive('gmfLayertree', gmf.layertreeDirective);


/**
 * @param {angular.$http} $http Angular http service.
 * @param {angular.$sce} $sce Angular sce service.
 * @param {ngeo.CreatePopup} ngeoCreatePopup Popup service.
 * @param {ngeo.LayerHelper} ngeoLayerHelper Ngeo Layer Helper.
 * @param {string} gmfWmsUrl URL to the wms service to use by default.
 * @constructor
 * @export
 * @ngInject
 * @ngdoc controller
 * @ngname gmfLayertreeController
 */
gmf.LayertreeController = function($http, $sce, ngeoCreatePopup,
    ngeoLayerHelper, gmfWmsUrl) {

  /**
   * @private
   * @type {angular.$http}
   */
  this.$http_ = $http;

  /**
   * @private
   * @type {angular.$sce}
   */
  this.$sce_ = $sce;

  /**
   * @type {string}
   * @private
   */
  this.gmfWmsUrl_ = gmfWmsUrl;

  /**
   * @type {ngeo.LayerHelper}
   * @private
   */
  this.layerHelper_ = ngeoLayerHelper;

  /**
   * @private
   * @type {ngeo.Popup}
   */
  this.infoPopup_ = ngeoCreatePopup();

  /**
   * @type {Object.&lt;string, !angular.$q.Promise>}
   * @private
   */
  this.promises_ = {};

  /**
   * @type {Object.&lt;number, Array.&lt;string>>}
   * @private
   */
  this.groupNodeStates_ = {};

  /**
   * @type {boolean}
   * @export
   */
  this.openLinksInNewWindow = this['openLinksInNewWindowFn']() === true ?
      true : false;
};


/**
 * @const
 */
gmf.LayertreeController.TYPE_MIXEDGROUP = 'MixedGroup';


/**
 * @const
 */
gmf.LayertreeController.TYPE_NOTMIXEDGROUP = 'NotMixedGroup';


/**
 * @const
 */
gmf.LayertreeController.TYPE_WMTS = 'WMTS';


/**
 * @const
 */
gmf.LayertreeController.TYPE_EXTERNALWMS = 'externalWMS';


/**
 * @const
 */
gmf.LayertreeController.TYPE_WMS = 'WMS';


/**
 * Return a "type" that defines the node.
 * @param {GmfThemesNode} node Layer tree node.
 * @return {string} A type.
 * @private
 */
gmf.LayertreeController.prototype.getNodeType_ = function(node) {
  var children = node.children;
  var mixed = node.mixed;
  if (goog.isDef(node.children) &amp;&amp; mixed) {
    return gmf.LayertreeController.TYPE_MIXEDGROUP;
  }
  if (goog.isDef(children) &amp;&amp; !mixed) {
    return gmf.LayertreeController.TYPE_NOTMIXEDGROUP;
  }
  if (node.type === 'WMTS') {
    return gmf.LayertreeController.TYPE_WMTS;
  }
  if (goog.isDefAndNotNull(node.url)) {
    return gmf.LayertreeController.TYPE_EXTERNALWMS;
  }
  return gmf.LayertreeController.TYPE_WMS;
};


/**
 * Create and return a layer corresponding to the ngeo layertree's node.
 * This function will only create a layer for each "top-level" (depth 1) groups.
 *
 * On "not mixed" type nodes, the returned layer will be an ol.layer.Image (WMS)
 * with each name of node's children as LAYERS parameters.
 *
 * On "mixed" type node, the returned  layer will be an ol.layer.Group with
 * a collection of layers that corresponds to each children of the node.
 *
 * All layer created will receive:
 *  - A 'querySourceId' parameter with the node id as value.
 *  - A 'layerName' parameter with the node name as value.
 *
 * All layer created will be added at the top of the map and with a Z Index
 * value of 1.
 *
 * If the node metadata 'isChecked' value is false, the layer visibility will
 * be set to false.
 * @param {GmfThemesNode} node Layer tree node.
 * @param {number=} opt_depth ngeo layertree node depth.
 * @param {boolean=} opt_createWMS True to allow create wms layer.
 * @return {ol.layer.Base} The OpenLayers layer or group for the node.
 * @export
 */
gmf.LayertreeController.prototype.getLayer = function(node, opt_depth,
        opt_createWMS) {
  var type = this.getNodeType_(node);
  var layer = null;

  if (opt_depth === 1) {
    switch (type) {
      case gmf.LayertreeController.TYPE_MIXEDGROUP:
        return this.getLayerCaseMixedGroup_(node);
      case gmf.LayertreeController.TYPE_NOTMIXEDGROUP:
        layer = this.getLayerCaseNotMixedGroup_(node);
        break;
      // no default
    }
    switch (type) {
      case gmf.LayertreeController.TYPE_WMTS:
        layer = this.getLayerCaseWMTS_(node);
        break;
      case gmf.LayertreeController.TYPE_WMS:
      case gmf.LayertreeController.TYPE_EXTERNALWMS:
        var url = node.url || this.gmfWmsUrl_;
        layer = opt_createWMS ?
            this.layerHelper_.createBasicWMSLayer(url, node.name) : null;
        break;
      // no default
    }
  }

  if (goog.isDefAndNotNull(layer)) {
    layer.set('querySourceId', node.id);
    layer.set('layerName', node.name);
    // The layer must be upper than the background
    layer.setZIndex(1);
    // Add the new layer on the map but behind (before) others layers
    this.map.getLayerGroup().getLayers().insertAt(0, layer);

    // If layer is 'unchecked', set it to invisible.
    var metadata = node.metadata;
    if (!goog.isDef(node.children) &amp;&amp; goog.isDefAndNotNull(metadata)) {
      if (metadata['isChecked'] != 'true') {
        layer.setVisible(false);
      }
    }
  }

  return layer;
};


/**
 * Create an ol.layer.Group with all node's children as layers except others
 * groups.
 * @param {GmfThemesNode} node Layer tree node.
 * @return {ol.layer.Group} Layer group.
 * @private
 */
gmf.LayertreeController.prototype.getLayerCaseMixedGroup_ = function(node) {
  var i;
  var layers = new ol.Collection();
  var layer, subNode;
  var subNodes = [];
  var nodeNames = [];
  this.getFlatNodes_(node, subNodes);
  for (i = 0; i &lt; subNodes.length; i++) {
    subNode = subNodes[i];
    // Create all sublayers include wms layers;
    layer = this.getLayer(subNode, 1, true);
    if (goog.isDefAndNotNull(layer)) {
      layers.push(layer);
      nodeNames.push(subNode.name);
    }
  }
  var group = this.layerHelper_.createBasicGroup(layers);

  // Keep a reference to this group.
  this.groupNodeStates_[goog.getUid(group)] = [];
  return group;
};


/**
 * Create an ol.layer.Image with all node's children as LAYERS params.
 * @param {GmfThemesNode} node Layer tree node.
 * @return {ol.layer.Image} Image layer.
 * @private
 */
gmf.LayertreeController.prototype.getLayerCaseNotMixedGroup_ = function(node) {
  var names = this.retrieveNodeNames_(node, true);
  var url = node.url || this.gmfWmsUrl_;
  var layer = this.layerHelper_.createBasicWMSLayer(url, '');
  this.updateWMSLayerState_(layer, names);

  // Keep a reference to this group with all layer name inside.
  this.groupNodeStates_[goog.getUid(layer)] = [];

  return layer;
};


/**
 * Create an ol.layer.Tile layer.
 * @param {GmfThemesNode} node Layertree node.
 * @return {ol.layer.Tile} The OpenLayers layer or group for the node.
 * @private
 */
gmf.LayertreeController.prototype.getLayerCaseWMTS_ = function(node) {
  var newLayer = new ol.layer.Tile();
  this.layerHelper_.createWMTSLayerFromCapabilitites(node.url || '', node.name)
    .then(function(layer) {
      newLayer.setSource(layer.getSource());
      newLayer.set('capabilitiesStyles', layer.get('capabilitiesStyles'));
    });
  return newLayer;
};


/**
 * Fill the given "nodes" array with all node in the given node including the
 * given node itself.
 * @param {GmfThemesNode} node Layertree node.
 * @param {Array.&lt;GmfThemesNode>} nodes An array.
 * @private
 */
gmf.LayertreeController.prototype.getFlatNodes_ = function(node, nodes) {
  var i;
  var children = node.children;
  if (goog.isDef(children)) {
    for (i = 0; i &lt; children.length; i++) {
      this.getFlatNodes_(children[i], nodes);
    }
  } else {
    nodes.push(node);
  }
};


/**
 * Return all names existing in a node and in its children.
 * @param {GmfThemesNode} node Layer tree node.
 * @param {boolean=} opt_onlyChecked return only 'isChecked' node names.
 * @return {Array.&lt;string>} An Array of all nodes names.
 * @private
 */
gmf.LayertreeController.prototype.retrieveNodeNames_ = function(node,
    opt_onlyChecked) {
  var names = [];
  var nodes = [];
  this.getFlatNodes_(node, nodes);
  var metadata, n, i;
  for (i = 0; i &lt; nodes.length; i++) {
    n = nodes[i];
    metadata = n.metadata;
    if (!opt_onlyChecked ||
        (goog.isDefAndNotNull(metadata) &amp;&amp; metadata['isChecked'] != 'false')) {
      names.push(n.name);
    }
  }
  return names;
};


/**
 * Retrieve the "top level" layertree.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @return {ngeo.LayertreeController} the top level layertree.
 * @private
 */
gmf.LayertreeController.prototype.retrieveFirstParentTree_ = function(treeCtrl) {
  var tree = treeCtrl;
  while (tree.depth > 1) {
    tree = tree.parent;
  }
  return tree;
};


/**
 * Remove layer from map on a ngeo layertree destroy event.
 * @param {angular.Scope} scope treeCtrl scope.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @export
 */
gmf.LayertreeController.prototype.listeners = function(scope, treeCtrl) {
  scope.$on('$destroy', angular.bind(treeCtrl, function() {
    // Remove treeCtrl.layer from map.
    treeCtrl.map.removeLayer(treeCtrl.layer);
  }));
};


/**
 * Return 'outOfResolution' if the current resolution of the map is out of
 * the min/max resolution in the node.
 * @param {GmfThemesNode} node Layer tree node.
 * @return {?string} 'outOfResolution' or null.
 * @export
 */
gmf.LayertreeController.prototype.getResolutionStyle = function(node) {
  var style;
  var resolution = this.map.getView().getResolution();
  var maxExtent = node.maxResolutionHint;
  var minExtent = node.minResolutionHint;
  if (goog.isDef(minExtent) &amp;&amp; resolution &lt; minExtent ||
      goog.isDef(maxExtent) &amp;&amp; resolution > maxExtent) {
    style = 'outOfResolution';
  }
  return style || null;
};


/**
 * Toggle the state of treeCtrl's node.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @export
 */
gmf.LayertreeController.prototype.toggleActive = function(treeCtrl) {
  var node = /** @type {GmfThemesNode} */ (treeCtrl.node);
  var type = this.getNodeType_(node);
  var layer = treeCtrl.layer;
  var i, layers, nodeNames;
  var firstParentTree = this.retrieveFirstParentTree_(treeCtrl);
  var firstParentTreeLayer = firstParentTree.layer;
  // Check if the current node state is 'activated'.
  var isActive = (this.getNodeState(treeCtrl) === 'on') ? true : false;

  // Deactivate/activate the corresponding layer(s).
  switch (type) {
    case gmf.LayertreeController.TYPE_WMS:
    case gmf.LayertreeController.TYPE_WMTS:
    case gmf.LayertreeController.TYPE_EXTERNALWMS:

      if (firstParentTreeLayer instanceof ol.layer.Group) {
        layer.setVisible(!isActive);

      } else {
        // If layer of the group is a wms in a not mixed group:
        var firstParentTreeSource = /** @type {ol.source.ImageWMS} */
            (firstParentTreeLayer.getSource());
        var firstParentTreeNode =  /** @type {GmfThemesNode} */
            (firstParentTree.node);
        var currentLayersNames = (firstParentTreeLayer.getVisible()) ?
            firstParentTreeSource.getParams()['LAYERS'].split(',') : [];
        var name, newLayersNames = [];
        nodeNames = this.retrieveNodeNames_(firstParentTreeNode);
        // Add/remove layer and keep order of layers in layergroup.
        for (i = 0; i &lt; nodeNames.length; i++) {
          name = nodeNames[i];
          if (name === node.name) {
            if (!isActive) {
              newLayersNames.push(name);
            }
          } else if (currentLayersNames.indexOf(name) >= 0) {
            newLayersNames.push(name);
          }
        }
        goog.asserts.assertInstanceof(firstParentTreeLayer, ol.layer.Image);
        this.updateWMSLayerState_(firstParentTreeLayer, newLayersNames);
      }
      break;

    case gmf.LayertreeController.TYPE_MIXEDGROUP:
      var nodeLayers = [];
      var l, source;
      nodeNames = this.retrieveNodeNames_(node);
      layers = this.layerHelper_.getFlatLayers(firstParentTreeLayer);
      for (i = 0; i &lt; layers.length; i++) {
        l = layers[i];
        source = layers[i].getSource();
        if (source instanceof ol.source.WMTS) {
          if (nodeNames.indexOf(source.getLayer()) >= 0) {
            nodeLayers.push(l);
          }
        } else if (source instanceof ol.source.ImageWMS) {
          if (nodeNames.indexOf(source.getParams()['LAYERS']) >= 0) {
            nodeLayers.push(l);
          }
        }
      }
      for (i = 0; i &lt; nodeLayers.length; i++) {
        nodeLayers[i].setVisible(!isActive);
      }
      break;

    case gmf.LayertreeController.TYPE_NOTMIXEDGROUP:
      nodeNames = this.retrieveNodeNames_(node);
      source = /** @type {ol.source.ImageWMS} */
          (firstParentTreeLayer.getSource());
      layers = firstParentTreeLayer.getVisible() ?
          source.getParams()['LAYERS'].split(',') : [];
      if (isActive) {
        for (i = 0; i &lt; nodeNames.length; i++) {
          goog.array.remove(layers, nodeNames[i]);
        }
      } else {
        for (i = 0; i &lt; nodeNames.length; i++) {
          goog.array.insert(layers, nodeNames[i]);
        }
      }
      firstParentTreeLayer = /** @type {ol.layer.Image} */
          (firstParentTreeLayer);
      this.updateWMSLayerState_(firstParentTreeLayer, layers);
      break;
    // no default
  }
};


/**
 * Return the current state of the given treeCtrl's node.
 * Return a class name that match with the current node activation state.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @return {string} 'on' or 'off' or 'indeterminate'.
 * @export
 */
gmf.LayertreeController.prototype.getNodeState = function(treeCtrl) {
  var style;
  var layer = treeCtrl.layer;
  var node = /** @type {GmfThemesNode} */ (treeCtrl.node);
  var type = this.getNodeType_(node);
  var firstParentTree = this.retrieveFirstParentTree_(treeCtrl);
  var firstParentTreeLayer = firstParentTree.layer;
  var firstParentTreeSource;
  var currentLayersNames = this.groupNodeStates_[
      goog.getUid(firstParentTreeLayer)];

  switch (type) {
    case gmf.LayertreeController.TYPE_WMS:
    case gmf.LayertreeController.TYPE_WMTS:
    case gmf.LayertreeController.TYPE_EXTERNALWMS:
      if (firstParentTreeLayer instanceof ol.layer.Group) {
        // If layer is not define (That occures the first time, because the
        // layer is just in the first parent group) add it to current tree to
        // save time next.
        if (!goog.isDefAndNotNull(layer)) {
          this.addLayerToLeaf_(treeCtrl);
          layer = treeCtrl.layer;
        }
        // Get style of this node depending if the relative layer is visible.
        style = goog.isDefAndNotNull(layer) &amp;&amp; layer.getVisible() ?
            'on' : 'off';

      } else {
        // If layer of the group is a wms in a not mixed group:
        firstParentTreeSource = /** @type {ol.source.ImageWMS} */
            (firstParentTreeLayer.getSource());
        var layersNames =
            firstParentTreeSource.getParams()['LAYERS'].split(',');
        // Get style for this layer depending if the layer is on the map or not
        // and if the layer is visible;
        style = layersNames.indexOf(node.name) &lt; 0 ||
            !firstParentTreeLayer.getVisible() ? 'off' : 'on';
      }

      // Update group state
      if (style === 'on') {
        goog.array.insert(currentLayersNames, node.name);
      } else {
        goog.array.remove(currentLayersNames, node.name);
      }

      break;

    case gmf.LayertreeController.TYPE_MIXEDGROUP:
    case gmf.LayertreeController.TYPE_NOTMIXEDGROUP:
      var nodeNames = this.retrieveNodeNames_(node);
      var i, found = 0;
      for (i = 0; i &lt; nodeNames.length; i++) {
        if (currentLayersNames.indexOf(nodeNames[i]) >= 0) {
          found++;
        }
      }
      if (found === 0) {
        style = 'off';
      } else if (found === nodeNames.length) {
        style = 'on';
      } else {
        style = 'indeterminate';
      }
      break;
    // no default
  }
  return style || 'off';
};


/**
 * Get the layer corresponding to the given layertree node from the layer
 * group "top level" layertree and add this layer to the given layertree.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @private
 */
gmf.LayertreeController.prototype.addLayerToLeaf_ = function(treeCtrl) {
  var groupTree = this.retrieveFirstParentTree_(treeCtrl);
  var layers = this.layerHelper_.getFlatLayers(groupTree.layer);
  var node = treeCtrl.node;
  var source, l, i;
  for (i = 0; i &lt; layers.length; i++) {
    l = layers[i];
    source = l.getSource();
    if (source instanceof ol.source.WMTS &amp;&amp;
        source.getLayer() === node.name) {
      treeCtrl.layer = l;
      break;
    } else if (source instanceof ol.source.ImageWMS &amp;&amp;
        source.getParams()['LAYERS'] === node.name) {
      treeCtrl.layer = l;
      break;
    }
  }
};


/**
 * Update the LAYERS parameter of the source of the given WMS layer.
 * @param {ol.layer.Image} layer The WMS layer.
 * @param {Array.&lt;string>} names The array of names that will be used to set
 * the LAYERS parameter.
 * @private
 */
gmf.LayertreeController.prototype.updateWMSLayerState_ = function(layer,
    names) {
  // Don't send layer without parameters, hide layer instead;
  if (names.length &lt;= 0) {
    layer.setVisible(false);
  } else {
    layer.setVisible(true);
    names.reverse();
    var source = /** @type {ol.source.ImageWMS} */ (layer.getSource());
    source.updateParams({'LAYERS': names.join(',')});
  }
};


/**
 * Get the icon image URL for the given treeCtrl's layer. It can only return a
 * string for internal WMS layers without multiple childlayers in the node.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @return {?string} The icon legend URL or null.
 * @export
 */
gmf.LayertreeController.prototype.getLegendIconURL = function(treeCtrl) {
  var node = /** @type {GmfThemesNode} */ (treeCtrl.node);
  var opt_legendRule = node.metadata['legendRule'];

  if (goog.isDef(node.children) ||
      !goog.isDef(opt_legendRule) ||
      node.type === 'WMTS' ||
      node.type === 'external WMS' ||
      goog.isDef(node.childLayers) &amp;&amp; node.childLayers.length > 1) {
    return null;
  }

  return this.getWMSLegendURL_(node, opt_legendRule);
};


/**
 * Get the legend URL for the given treeCtrl.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @return {?string} The legend URL or null.
 * @export
 */
gmf.LayertreeController.prototype.getLegendURL = function(treeCtrl) {
  var node = /** @type {GmfThemesNode} */ (treeCtrl.node);

  if (goog.isDef(node.children)) {
    return null;
  }

  var layer = treeCtrl.layer;
  if (node.type === 'WMTS' &amp;&amp; goog.isDefAndNotNull(layer)) {
    goog.asserts.assertInstanceof(layer, ol.layer.Tile);
    return this.getWMTSLegendURL_(layer);
  } else {
    return this.getWMSLegendURL_(node);
  }
};


/**
 * Get the WMTS legend URL for the given layer.
 * @param {ol.layer.Tile} layer Tile layer as returned by the
 * gmf layerHelper service.
 * @return {?string} The legend URL or null.
 * @private
 */
gmf.LayertreeController.prototype.getWMTSLegendURL_ = function(layer) {
  // FIXME case of multiple styles ?  case of multiple legendUrl ?
  var url;
  var styles = layer.get('capabilitiesStyles');
  if (goog.isDef(styles)) {
    var legendURL = styles[0]['legendURL'];
    if (goog.isDef(legendURL)) {
      url = legendURL[0]['href'];
    }
  }
  return url || null;
};


/**
 * Get the WMS legend URL for the given node.
 * @param {GmfThemesNode} node Layer tree node.
 * @param {string=} opt_legendRule rule parameters to add to the returned URL.
 * @return {?string} The legend URL or null.
 * @private
 */
gmf.LayertreeController.prototype.getWMSLegendURL_ = function(node,
    opt_legendRule) {
  var scale = this.getScale_();
  var url = node.url || this.gmfWmsUrl_;
  if (goog.isDef(url)) {
    url = goog.uri.utils.setParam(url, 'FORMAT', 'image/png');
    url = goog.uri.utils.setParam(url, 'TRANSPARENT', true);
    url = goog.uri.utils.setParam(url, 'SERVICE', 'wms');
    url = goog.uri.utils.setParam(url, 'VERSION', '1.1.1');
    url = goog.uri.utils.setParam(url, 'REQUEST', 'GetLegendGraphic');
    url = goog.uri.utils.setParam(url, 'LAYER', node.name);
    url = goog.uri.utils.setParam(url, 'SCALE', scale);
    if (goog.isDef(opt_legendRule)) {
      url = goog.uri.utils.setParam(url, 'RULE', opt_legendRule);
    }
  }
  return url || null;
};


/**
 * Return the current scale of the map.
 * @return {number} Scale.
 * @private
 */
gmf.LayertreeController.prototype.getScale_ = function() {
  var view = this.map.getView();
  var resolution = view.getResolution();
  var mpu = view.getProjection().getMetersPerUnit();
  var dpi = 25.4 / 0.28;
  return resolution * mpu * 39.37 * dpi;
};


/**
 * Display a ngeo.infoPopup with the content of the metadata url of a node.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @export
 */
gmf.LayertreeController.prototype.displayMetadata = function(treeCtrl) {
  var treeUid = treeCtrl['uid'].toString();
  var node = treeCtrl.node;
  var metadataURL = node.metadata['metadataUrl'];
  if (goog.isDef(metadataURL)) {
    if (!(treeUid in this.promises_)) {
      this.promises_[treeUid] = this.$http_.get(metadataURL).then(
          angular.bind(this, function(resp) {
            var html = this.$sce_.trustAsHtml(resp.data);
            return html;
          }));
    }
    var infoPopup = this.infoPopup_;
    this.promises_[treeUid].then(function(html) {
      infoPopup.setTitle(node.name);
      infoPopup.setContent(html);
      infoPopup.setOpen(true);
    });
  }
};


/**
 * Return 'noSource' if no source is defined in the given treeCtrl's WMTS layer.
 * @param {ngeo.LayertreeController} treeCtrl ngeo layertree controller, from
 *     the current node.
 * @return {?string} 'noSource' or null
 * @export
 */
gmf.LayertreeController.prototype.getNoSourceStyle = function(treeCtrl) {
  var layer = treeCtrl.layer;
  if (goog.isDef(layer) &amp;&amp;
      layer instanceof ol.layer.Tile &amp;&amp;
      goog.isDef(layer.getSource) &amp;&amp;
      !goog.isDefAndNotNull(layer.getSource())) {
    return 'noSource';
  }
  return null;
};


/**
 * Set the resolution of the map with the max or min resolution of the node.
 * @param {GmfThemesNode} node Layer tree node.
 * @export
 */
gmf.LayertreeController.prototype.zoomToResolution = function(node) {
  var view = this.map.getView();
  var resolution = node.minResolutionHint || node.maxResolutionHint;
  if (goog.isDef(resolution)) {
    view.setResolution(resolution);
  }
};


gmf.module.controller('GmfLayertreeController', gmf.LayertreeController);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h2>gmf</h2><h3>Directives</h3><ul><li><a href="gmf.authenticationDirective.html">authenticationDirective</a></li><li><a href="gmf.layertreeDirective.html">layertreeDirective</a></li><li><a href="gmf.mapDirective.html">mapDirective</a></li><li><a href="gmf.mobileBackgroundLayerSelectorDirective.html">mobileBackgroundLayerSelectorDirective</a></li><li><a href="gmf.mobiledisplayqueriesDirective.html">mobiledisplayqueriesDirective</a></li><li><a href="gmf.mobileMeasureLengthDirective.html">mobileMeasureLengthDirective</a></li><li><a href="gmf.mobileMeasurePointDirective.html">mobileMeasurePointDirective</a></li><li><a href="gmf.searchDirective.html">searchDirective</a></li><li><a href="gmf.themeselectorDirective.html">themeselectorDirective</a></li></ul><h3>Services</h3><ul><li><a href="gmf.Altitude.html">Altitude</a></li><li><a href="gmf.Permalink.html">Permalink</a></li><li><a href="gmf.QueryManager.html">QueryManager</a></li><li><a href="gmf.Themes.html">Themes</a></li></ul><h3>Controllers</h3><ul><li><a href="gmf.AuthenticationController.html">AuthenticationController</a></li><li><a href="gmf.LayertreeController.html">LayertreeController</a></li><li><a href="gmf.MapController.html">MapController</a></li><li><a href="gmf.MobileBackgroundLayerSelectorController.html">MobileBackgroundLayerSelectorController</a></li><li><a href="gmf.MobileMeasureLengthController.html">MobileMeasureLengthController</a></li><li><a href="gmf.MobileMeasurePointController.html">MobileMeasurePointController</a></li><li><a href="gmf.MobileNavController.html">MobileNavController</a></li><li><a href="gmf.SearchController.html">SearchController</a></li><li><a href="gmf.ThemeselectorController.html">ThemeselectorController</a></li></ul><h3>Classes</h3><ul><li><a href="gmf.AbstractController.html">AbstractController</a></li><li><a href="gmf.AbstractDesktopController.html">AbstractDesktopController</a></li><li><a href="gmf.AbstractMobileController.html">AbstractMobileController</a></li><li><a href="gmf.Authentication.html">Authentication</a></li><li><a href="gmf.MobiledisplayqueriesController.html">MobiledisplayqueriesController</a></li></ul><h3>Types</h3><ul><li><a href="gmf.html#AuthenticationDefaultResponse">AuthenticationDefaultResponse</a></li><li><a href="gmf.html#AuthenticationFunctionalities">AuthenticationFunctionalities</a></li><li><a href="gmf.html#AuthenticationLoginResponse">AuthenticationLoginResponse</a></li><li><a href="gmf.html#ExportFeatures">ExportFeatures</a></li><li><a href="gmf.html#ThemesResponse">ThemesResponse</a></li><li><a href="gmf.html#User">User</a></li></ul><h3>Enumerations</h3><ul><li><a href="gmf.html#AltitudeParam">AltitudeParam</a></li><li><a href="gmf.html#AuthenticationRouteSuffix">AuthenticationRouteSuffix</a></li><li><a href="gmf.html#ExportFormat">ExportFormat</a></li><li><a href="gmf.html#PermalinkParam">PermalinkParam</a></li><li><a href="gmf.html#ThemesEventType">ThemesEventType</a></li></ul><h2>gmf.source</h2><h3>Classes</h3><ul><li><a href="gmf.source.AsitVD.html">AsitVD</a></li><li><a href="gmf.source.Swisstopo.html">Swisstopo</a></li></ul><h2>ngeo</h2><h3>Directives</h3><ul><li><a href="ngeo.btnDirective.html">btnDirective</a></li><li><a href="ngeo.btngroupDirective.html">btngroupDirective</a></li><li><a href="ngeo.controlDirective.html">controlDirective</a></li><li><a href="ngeo.desktopGeolocationDirective.html">desktopGeolocationDirective</a></li><li><a href="ngeo.filereaderDirective.html">filereaderDirective</a></li><li><a href="ngeo.layertreeDirective.html">layertreeDirective</a></li><li><a href="ngeo.mapDirective.html">mapDirective</a></li><li><a href="ngeo.mobileGeolocationDirective.html">mobileGeolocationDirective</a></li><li><a href="ngeo.mobileQueryDirective.html">mobileQueryDirective</a></li><li><a href="ngeo.modalDirective.html">modalDirective</a></li><li><a href="ngeo.profileDirective.html">profileDirective</a></li><li><a href="ngeo.recenterDirective.html">recenterDirective</a></li><li><a href="ngeo.resizemapDirective.html">resizemapDirective</a></li><li><a href="ngeo.scaleselectorDirective.html">scaleselectorDirective</a></li><li><a href="ngeo.searchDirective.html">searchDirective</a></li><li><a href="ngeo.sortableDirective.html">sortableDirective</a></li></ul><h3>Services</h3><ul><li><a href="ngeo.BackgroundLayerMgr.html">BackgroundLayerMgr</a></li><li><a href="ngeo.CreateGeoJSONBloodhound.html">CreateGeoJSONBloodhound</a></li><li><a href="ngeo.createPrintServiceFactory.html">createPrintServiceFactory</a></li><li><a href="ngeo.Debounce.html">Debounce</a></li><li><a href="ngeo.DecorateGeolocation.html">DecorateGeolocation</a></li><li><a href="ngeo.DecorateInteraction.html">DecorateInteraction</a></li><li><a href="ngeo.DecorateLayer.html">DecorateLayer</a></li><li><a href="ngeo.FeatureOverlayMgr.html">FeatureOverlayMgr</a></li><li><a href="ngeo.getBrowserLanguageFactory.html">getBrowserLanguageFactory</a></li><li><a href="ngeo.LayerHelper.html">LayerHelper</a></li><li><a href="ngeo.Location.html">Location</a></li><li><a href="ngeo.Popup.html">Popup</a></li><li><a href="ngeo.PrintUtils.html">PrintUtils</a></li><li><a href="ngeo.Query.html">Query</a></li><li><a href="ngeo.SyncArrays.html">SyncArrays</a></li><li><a href="ngeo.ToolActivateMgr.html">ToolActivateMgr</a></li></ul><h3>Controllers</h3><ul><li><a href="ngeo.BtnGroupController.html">BtnGroupController</a></li><li><a href="ngeo.DesktopGeolocationController.html">DesktopGeolocationController</a></li><li><a href="ngeo.LayertreeController.html">LayertreeController</a></li><li><a href="ngeo.MobileGeolocationController.html">MobileGeolocationController</a></li><li><a href="ngeo.MobileQueryController.html">MobileQueryController</a></li><li><a href="ngeo.ScaleselectorController.html">ScaleselectorController</a></li></ul><h3>Classes</h3><ul><li><a href="ngeo.BackgroundEvent.html">BackgroundEvent</a></li><li><a href="ngeo.FeatureOverlay.html">FeatureOverlay</a></li><li><a href="ngeo.MeasureEvent.html">MeasureEvent</a></li><li><a href="ngeo.Print.html">Print</a></li><li><a href="ngeo.profile.html">profile</a></li><li><a href="ngeo.StateManager.html">StateManager</a></li><li><a href="ngeo.ToolActivate.html">ToolActivate</a></li></ul><h3>Types</h3><ul><li><a href="ngeo.html#CreatePopup">CreatePopup</a></li><li><a href="ngeo.html#CreatePrint">CreatePrint</a></li><li><a href="ngeo.html#FeatureOverlayGroup">FeatureOverlayGroup</a></li><li><a href="ngeo.html#GetBrowserLanguage">GetBrowserLanguage</a></li><li><a href="ngeo.html#MockLocationProvider">MockLocationProvider</a></li><li><a href="ngeo.html#QueryCacheItem">QueryCacheItem</a></li><li><a href="ngeo.html#QueryResult">QueryResult</a></li><li><a href="ngeo.html#QueryResultSource">QueryResultSource</a></li><li><a href="ngeo.html#ScaleselectorOptions">ScaleselectorOptions</a></li><li><a href="ngeo.html#SortableOptions">SortableOptions</a></li><li><a href="ngeo.html#ToolMgrEntry">ToolMgrEntry</a></li></ul><h3>Enumerations</h3><ul><li><a href="ngeo.html#BackgroundEventType">BackgroundEventType</a></li><li><a href="ngeo.html#MeasureEventType">MeasureEventType</a></li><li><a href="ngeo.html#PrintStyleType">PrintStyleType</a></li><li><a href="ngeo.html#QueryInfoFormatType">QueryInfoFormatType</a></li></ul><h2>ngeo.format</h2><h3>Classes</h3><ul><li><a href="ngeo.format.FeatureHash.html">FeatureHash</a></li></ul><h3>Enumerations</h3><ul><li><a href="ngeo.format.html#FeatureHashStyleType">FeatureHashStyleType</a></li></ul><h2>ngeo.interaction</h2><h3>Classes</h3><ul><li><a href="ngeo.interaction.DrawAzimut.html">DrawAzimut</a></li><li><a href="ngeo.interaction.Measure.html">Measure</a></li><li><a href="ngeo.interaction.MeasureArea.html">MeasureArea</a></li><li><a href="ngeo.interaction.MeasureAzimut.html">MeasureAzimut</a></li><li><a href="ngeo.interaction.MeasureLength.html">MeasureLength</a></li><li><a href="ngeo.interaction.MeasureLengthMobile.html">MeasureLengthMobile</a></li><li><a href="ngeo.interaction.MeasurePointMobile.html">MeasurePointMobile</a></li><li><a href="ngeo.interaction.MobileDraw.html">MobileDraw</a></li></ul><h3>Types</h3><ul><li><a href="ngeo.interaction.html#MeasureBaseOptions">MeasureBaseOptions</a></li></ul><h3>Enumerations</h3><ul><li><a href="ngeo.interaction.html#MobileDrawProperty">MobileDrawProperty</a></li></ul><h2>ngeo.MeasureEvent</h2><h3>Events</h3><ul><li><a href="ngeo.MeasureEvent.html#event:measureend">measureend</a></li></ul><h2>ngeox</h2><h3>Interfaces</h3><ul><li><a href="ngeox.BackgroundEvent.html">BackgroundEvent</a></li><li><a href="ngeox.MeasureEvent.html">MeasureEvent</a></li></ul><h3>Types</h3><ul><li><a href="ngeox.html#DesktopGeolocationDirectiveOptions">DesktopGeolocationDirectiveOptions</a></li><li><a href="ngeox.html#MobileGeolocationDirectiveOptions">MobileGeolocationDirectiveOptions</a></li><li><a href="ngeox.html#QueryOptions">QueryOptions</a></li><li><a href="ngeox.html#QuerySource">QuerySource</a></li><li><a href="ngeox.html#SearchDirectiveListeners">SearchDirectiveListeners</a></li></ul><h2>gmfx</h2><h3>Types</h3><ul><li><a href="gmfx.html#Config">Config</a></li><li><a href="gmfx.html#SearchDirectiveDatasource">SearchDirectiveDatasource</a></li><li><a href="gmfx.html#ServiceUrls">ServiceUrls</a></li></ul><h2>gmfx.source</h2><h3>Types</h3><ul><li><a href="gmfx.source.html#AsitVDOptions">AsitVDOptions</a></li><li><a href="gmfx.source.html#SwisstopoOptions">SwisstopoOptions</a></li></ul><h2>ngeox.format</h2><h3>Types</h3><ul><li><a href="ngeox.format.html#FeatureHashOptions">FeatureHashOptions</a></li></ul><h2>ngeox.interaction</h2><h3>Types</h3><ul><li><a href="ngeox.interaction.html#MeasureOptions">MeasureOptions</a></li><li><a href="ngeox.interaction.html#MobileDrawOptions">MobileDrawOptions</a></li></ul><h2>ngeox.profile</h2><h3>Types</h3><ul><li><a href="ngeox.profile.html#ElevationExtractor">ElevationExtractor</a></li><li><a href="ngeox.profile.html#PoiExtractor">PoiExtractor</a></li><li><a href="ngeox.profile.html#ProfileFormatter">ProfileFormatter</a></li><li><a href="ngeox.profile.html#ProfileOptions">ProfileOptions</a></li></ul><h3>Global</h3><ul><li><a href="global.html#gmfx">gmfx</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
